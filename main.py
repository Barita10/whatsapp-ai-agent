# Agent IA WhatsApp - Syst√®me de Commandes
# Architecture compl√®te avec FastAPI, SQLAlchemy, et int√©gration WhatsApp Business API

import os
import json
import logging
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

# D√©pendances requises
"""
pip install fastapi uvicorn sqlalchemy psycopg2-binary
pip install requests python-dotenv openai anthropic
pip install python-multipart jinja2
"""

from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.responses import JSONResponse
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Float, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
import requests
from openai import OpenAI
import anthropic

# Configuration
@dataclass
class Config:
    WHATSAPP_TOKEN: str = os.getenv("WHATSAPP_TOKEN", "your_whatsapp_token")
    WHATSAPP_PHONE_ID: str = os.getenv("WHATSAPP_PHONE_ID", "your_phone_id")
    WHATSAPP_VERIFY_TOKEN: str = os.getenv("WHATSAPP_VERIFY_TOKEN", "verify_token_123")
    OPENAI_API_KEY: str = os.getenv("OPENAI_API_KEY", "your_openai_key")
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./whatsapp_orders.db")
    
config = Config()

# Base de donn√©es
engine = create_engine(config.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class OrderStatus(Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    PREPARING = "preparing"
    READY = "ready"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

# Mod√®les de base de donn√©es
class Customer(Base):
    __tablename__ = "customers"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, unique=True, index=True)
    name = Column(String)
    address = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    orders = relationship("Order", back_populates="customer")

class Product(Base):
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    description = Column(Text)
    price = Column(Float)
    category = Column(String)
    available = Column(String, default="true")
    
class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    customer_id = Column(Integer, ForeignKey("customers.id"))
    status = Column(String, default=OrderStatus.PENDING.value)
    total_amount = Column(Float)
    items = Column(Text)  # JSON string des articles
    notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow)
    
    customer = relationship("Customer", back_populates="orders")

class Conversation(Base):
    __tablename__ = "conversations"
    
    id = Column(Integer, primary_key=True, index=True)
    phone_number = Column(String, index=True)
    context = Column(Text)  # Contexte de la conversation en JSON
    last_interaction = Column(DateTime, default=datetime.utcnow)

# Cr√©er les tables
Base.metadata.create_all(bind=engine)

# D√©pendance pour obtenir la session DB
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Service d'IA pour traitement du langage naturel
class AIService:
    def __init__(self):
        self.openai_client = OpenAI(api_key=config.OPENAI_API_KEY)
        
    def process_message(self, message: str, context: Dict = None) -> Dict:
        """Traite le message avec l'IA pour extraire l'intention et les entit√©s"""
        
        system_prompt = """
        Tu es un assistant IA pour un syst√®me de commandes via WhatsApp.
        Analyse le message du client et r√©ponds en JSON avec:
        - intent: "order", "inquiry", "modify_order", "cancel_order", "greeting", "other"
        - entities: objets extraits (produits, quantit√©s, etc.)
        - response: r√©ponse √† envoyer au client
        - action_needed: action sp√©cifique requise
        
        Produits disponibles:
        - Pizza Margherita (‚Ç¨12)
        - Pizza Pepperoni (‚Ç¨14)
        - Pasta Carbonara (‚Ç¨10)
        - Salade C√©sar (‚Ç¨8)
        - Coca-Cola (‚Ç¨3)
        - Eau (‚Ç¨2)
        """
        
        try:
            response = self.openai_client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"Message: {message}\nContexte: {context}"}
                ],
                temperature=0.3
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            logging.error(f"Erreur IA: {e}")
            return {
                "intent": "other",
                "entities": {},
                "response": "D√©sol√©, je n'ai pas compris. Pouvez-vous reformuler?",
                "action_needed": "clarification"
            }

# Service WhatsApp
class WhatsAppService:
    def __init__(self):
        self.token = config.WHATSAPP_TOKEN
        self.phone_id = config.WHATSAPP_PHONE_ID
        self.base_url = f"https://graph.facebook.com/v18.0/{self.phone_id}"
        
    def send_message(self, to: str, message: str) -> bool:
        """Envoie un message texte"""
        url = f"{self.base_url}/messages"
        headers = {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        }
        
        data = {
            "messaging_product": "whatsapp",
            "to": to,
            "text": {"body": message}
        }
        
        try:
            response = requests.post(url, json=data, headers=headers)
            return response.status_code == 200
        except Exception as e:
            logging.error(f"Erreur envoi message: {e}")
            return False
    
    def send_interactive_menu(self, to: str, products: List[Dict]) -> bool:
        """Envoie un menu interactif"""
        url = f"{self.base_url}/messages"
        headers = {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        }
        
        sections = [{
            "title": "Notre Menu",
            "rows": [
                {
                    "id": f"product_{p['id']}",
                    "title": p['name'],
                    "description": f"{p['description']} - ‚Ç¨{p['price']}"
                } for p in products[:10]  # Limite WhatsApp
            ]
        }]
        
        data = {
            "messaging_product": "whatsapp",
            "to": to,
            "type": "interactive",
            "interactive": {
                "type": "list",
                "header": {"type": "text", "text": "üçï Menu Restaurant"},
                "body": {"text": "Choisissez vos articles:"},
                "footer": {"text": "Tapez 'commander' pour finaliser"},
                "action": {
                    "button": "Voir Menu",
                    "sections": sections
                }
            }
        }
        
        try:
            response = requests.post(url, json=data, headers=headers)
            return response.status_code == 200
        except Exception as e:
            logging.error(f"Erreur menu interactif: {e}")
            return False

# Service de gestion des commandes
class OrderService:
    def __init__(self, db: Session):
        self.db = db
        
    def get_or_create_customer(self, phone_number: str) -> Customer:
        """R√©cup√®re ou cr√©e un client"""
        customer = self.db.query(Customer).filter(Customer.phone_number == phone_number).first()
        if not customer:
            customer = Customer(phone_number=phone_number)
            self.db.add(customer)
            self.db.commit()
            self.db.refresh(customer)
        return customer
    
    def create_order(self, phone_number: str, items: List[Dict], notes: str = "") -> Order:
        """Cr√©e une nouvelle commande"""
        customer = self.get_or_create_customer(phone_number)
        
        # Calculer le total
        total = sum(item['price'] * item['quantity'] for item in items)
        
        order = Order(
            customer_id=customer.id,
            total_amount=total,
            items=json.dumps(items),
            notes=notes
        )
        
        self.db.add(order)
        self.db.commit()
        self.db.refresh(order)
        return order
    
    def get_customer_orders(self, phone_number: str) -> List[Order]:
        """R√©cup√®re les commandes d'un client"""
        customer = self.get_or_create_customer(phone_number)
        return self.db.query(Order).filter(Order.customer_id == customer.id).all()

# Service principal de conversation
class ConversationService:
    def __init__(self, db: Session):
        self.db = db
        self.ai_service = AIService()
        self.whatsapp_service = WhatsAppService()
        self.order_service = OrderService(db)
        
    def get_conversation_context(self, phone_number: str) -> Dict:
        """R√©cup√®re le contexte de conversation"""
        conv = self.db.query(Conversation).filter(Conversation.phone_number == phone_number).first()
        if conv and conv.context:
            return json.loads(conv.context)
        return {"state": "new", "current_order": [], "step": "greeting"}
    
    def update_conversation_context(self, phone_number: str, context: Dict):
        """Met √† jour le contexte de conversation"""
        conv = self.db.query(Conversation).filter(Conversation.phone_number == phone_number).first()
        if not conv:
            conv = Conversation(phone_number=phone_number)
            self.db.add(conv)
        
        conv.context = json.dumps(context)
        conv.last_interaction = datetime.utcnow()
        self.db.commit()
    
    def process_incoming_message(self, phone_number: str, message: str) -> str:
        """Traite un message entrant et g√©n√®re une r√©ponse"""
        context = self.get_conversation_context(phone_number)
        
        # Analyser le message avec l'IA
        ai_response = self.ai_service.process_message(message, context)
        
        response = ""
        
        if ai_response["intent"] == "greeting":
            response = "üçï Bonjour! Bienvenue chez Restaurant Bot. Tapez 'menu' pour voir nos plats ou d√©crivez ce que vous souhaitez commander!"
            context["state"] = "menu_requested"
            
        elif ai_response["intent"] == "inquiry" and "menu" in message.lower():
            # Envoyer le menu interactif
            products = self.db.query(Product).filter(Product.available == "true").all()
            products_dict = [{"id": p.id, "name": p.name, "description": p.description, "price": p.price} for p in products]
            
            self.whatsapp_service.send_interactive_menu(phone_number, products_dict)
            response = "üìã Voici notre menu! Vous pouvez aussi me dire directement ce que vous voulez, par exemple: 'Je veux 2 pizzas margherita et 1 coca'"
            
        elif ai_response["intent"] == "order":
            # Traiter la commande
            entities = ai_response.get("entities", {})
            if "items" in entities:
                context["current_order"].extend(entities["items"])
                total = sum(item.get("price", 0) * item.get("quantity", 1) for item in context["current_order"])
                
                order_summary = "\n".join([f"‚Ä¢ {item['quantity']}x {item['name']} - ‚Ç¨{item['price']*item['quantity']}" 
                                         for item in context["current_order"]])
                
                response = f"‚úÖ Ajout√© √† votre commande!\n\nüìã R√©capitulatif:\n{order_summary}\n\nüí∞ Total: ‚Ç¨{total:.2f}\n\nTapez 'confirmer' pour valider ou continuez √† ajouter des articles."
                context["state"] = "order_building"
            else:
                response = "Je n'ai pas bien compris votre commande. Pouvez-vous pr√©ciser les articles et quantit√©s? Par exemple: '2 pizzas margherita'"
                
        elif ai_response["intent"] == "modify_order" and "confirmer" in message.lower():
            if context["current_order"]:
                # Cr√©er la commande
                order = self.order_service.create_order(phone_number, context["current_order"])
                response = f"üéâ Commande confirm√©e! Num√©ro: #{order.id}\n\n‚è∞ Temps de pr√©paration: 25-30 minutes\nüí∞ Total: ‚Ç¨{order.total_amount:.2f}\n\nVous recevrez une notification quand c'est pr√™t!"
                context = {"state": "order_confirmed", "current_order": [], "last_order_id": order.id}
            else:
                response = "Votre panier est vide. Ajoutez des articles avant de confirmer!"
                
        else:
            response = ai_response.get("response", "Je n'ai pas compris. Tapez 'menu' pour voir nos options!")
        
        # Sauvegarder le contexte
        self.update_conversation_context(phone_number, context)
        
        return response

# Application FastAPI
app = FastAPI(title="WhatsApp AI Agent - Syst√®me de Commandes")

# Endpoints
@app.get("/")
async def root():
    return {"message": "WhatsApp AI Agent actif!", "status": "running"}

@app.get("/webhook")
async def verify_webhook(request: Request):
    """V√©rification du webhook WhatsApp"""
    verify_token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")
    
    if verify_token == config.WHATSAPP_VERIFY_TOKEN:
        return int(challenge)
    else:
        raise HTTPException(status_code=403, detail="Token invalide")

@app.post("/webhook")
async def handle_webhook(request: Request, db: Session = Depends(get_db)):
    """Traite les messages WhatsApp entrants"""
    try:
        body = await request.json()
        
        if "messages" in body.get("entry", [{}])[0].get("changes", [{}])[0].get("value", {}):
            messages = body["entry"][0]["changes"][0]["value"]["messages"]
            
            for message in messages:
                phone_number = message["from"]
                message_body = message.get("text", {}).get("body", "")
                
                if message_body:  # Ignorer les messages vides
                    conversation_service = ConversationService(db)
                    response = conversation_service.process_incoming_message(phone_number, message_body)
                    
                    # Envoyer la r√©ponse
                    whatsapp_service = WhatsAppService()
                    whatsapp_service.send_message(phone_number, response)
        
        return JSONResponse(content={"status": "success"})
        
    except Exception as e:
        logging.error(f"Erreur webhook: {e}")
        return JSONResponse(content={"error": str(e)}, status_code=500)

@app.post("/admin/products")
async def create_product(name: str, description: str, price: float, category: str, db: Session = Depends(get_db)):
    """Cr√©er un nouveau produit"""
    product = Product(name=name, description=description, price=price, category=category)
    db.add(product)
    db.commit()
    db.refresh(product)
    return {"message": "Produit cr√©√©", "product_id": product.id}

@app.get("/admin/orders")
async def get_orders(db: Session = Depends(get_db)):
    """R√©cup√©rer toutes les commandes"""
    orders = db.query(Order).all()
    return [{"id": o.id, "customer_phone": o.customer.phone_number, 
             "total": o.total_amount, "status": o.status, "created_at": o.created_at} for o in orders]

@app.put("/admin/orders/{order_id}/status")
async def update_order_status(order_id: int, status: str, db: Session = Depends(get_db)):
    """Mettre √† jour le statut d'une commande"""
    order = db.query(Order).filter(Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Commande introuvable")
    
    order.status = status
    order.updated_at = datetime.utcnow()
    db.commit()
    
    # Notifier le client
    whatsapp_service = WhatsAppService()
    status_messages = {
        "confirmed": "‚úÖ Votre commande a √©t√© confirm√©e!",
        "preparing": "üë®‚Äçüç≥ Votre commande est en pr√©paration...",
        "ready": "üéâ Votre commande est pr√™te! Vous pouvez venir la r√©cup√©rer.",
        "delivered": "üì¶ Commande livr√©e! Merci et √† bient√¥t!",
        "cancelled": "‚ùå Votre commande a √©t√© annul√©e. Contactez-nous pour plus d'infos."
    }
    
    if status in status_messages:
        whatsapp_service.send_message(
            order.customer.phone_number, 
            f"Commande #{order.id}: {status_messages[status]}"
        )
    
    return {"message": "Statut mis √† jour"}

# Configuration de logging
logging.basicConfig(level=logging.INFO)

# Donn√©es de test pour initialiser la base
def init_sample_data():
    db = SessionLocal()
    try:
        if db.query(Product).count() == 0:
            products = [
                Product(name="Pizza Margherita", description="Tomate, mozzarella, basilic", price=12.0, category="Pizza"),
                Product(name="Pizza Pepperoni", description="Tomate, mozzarella, pepperoni", price=14.0, category="Pizza"),
                Product(name="Pasta Carbonara", description="P√¢tes, lardons, cr√®me, parmesan", price=10.0, category="Pasta"),
                Product(name="Salade C√©sar", description="Salade, poulet, parmesan, cro√ªtons", price=8.0, category="Salade"),
                Product(name="Coca-Cola", description="Boisson gazeuse 33cl", price=3.0, category="Boisson"),
                Product(name="Eau", description="Eau min√©rale 50cl", price=2.0, category="Boisson"),
            ]
            
            for product in products:
                db.add(product)
            db.commit()
            print("‚úÖ Donn√©es de test initialis√©es!")
    finally:
        db.close()

if __name__ == "__main__":
    init_sample_data()
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

# Instructions de d√©ploiement et configuration dans le README ci-dessous
"""
# ü§ñ Agent IA WhatsApp - Syst√®me de Commandes

## üìã Fonctionnalit√©s

‚úÖ **Conversation naturelle**: L'IA comprend les demandes en langage naturel
‚úÖ **Menu interactif**: Affichage du menu avec boutons WhatsApp  
‚úÖ **Gestion des commandes**: Ajout, modification, confirmation
‚úÖ **Suivi en temps r√©el**: Notifications de statut automatiques
‚úÖ **Interface admin**: Gestion des produits et commandes
‚úÖ **Base de donn√©es**: Stockage persistant des donn√©es

## üöÄ Installation

1. **Cloner le projet**:
```bash
git clone <repo>
cd whatsapp-ai-agent
```

2. **Installer les d√©pendances**:
```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary
pip install requests python-dotenv openai anthropic
pip install python-multipart jinja2
```

3. **Configuration environnement** (.env):
```env
WHATSAPP_TOKEN=your_whatsapp_business_token
WHATSAPP_PHONE_ID=your_phone_number_id  
WHATSAPP_VERIFY_TOKEN=your_verify_token
OPENAI_API_KEY=your_openai_key
DATABASE_URL=postgresql://user:password@localhost/whatsapp_orders
```

4. **Lancer l'application**:
```bash
python main.py
```

## ‚öôÔ∏è Configuration WhatsApp Business

1. Cr√©er une app Meta Developer
2. Configurer WhatsApp Business API
3. Obtenir le token et phone_id  
4. Configurer le webhook: `https://yourdomain.com/webhook`
5. V√©rifier avec le verify_token

## üì± Utilisation

**Commandes clients:**
- "Bonjour" ‚Üí Accueil
- "Menu" ‚Üí Affichage menu interactif  
- "Je veux 2 pizzas margherita" ‚Üí Ajouter √† la commande
- "Confirmer" ‚Üí Valider la commande

**Interface admin:**
- `GET /admin/orders` ‚Üí Liste des commandes
- `PUT /admin/orders/{id}/status` ‚Üí Changer statut
- `POST /admin/products` ‚Üí Ajouter produit

## üîß Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   WhatsApp      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  FastAPI Server  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   Database      ‚îÇ
‚îÇ   Business API  ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ   PostgreSQL    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îÇ  OpenAI API  ‚îÇ
                       ‚îÇ  (Processing)‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Flux de conversation

1. **Client** ‚Üí Message WhatsApp
2. **Webhook** ‚Üí R√©ception FastAPI  
3. **IA** ‚Üí Analyse et extraction d'entit√©s
4. **Logique** ‚Üí Traitement de la commande
5. **R√©ponse** ‚Üí Envoi via WhatsApp API
6. **Suivi** ‚Üí Notifications automatiques

## üìä Exemples d'interaction

**Client**: "Salut, je voudrais commander"  
**Bot**: "üçï Bonjour! Bienvenue chez Restaurant Bot..."

**Client**: "2 pizzas margherita et 1 coca"  
**Bot**: "‚úÖ Ajout√© √† votre commande!\nüìã R√©capitulatif:\n‚Ä¢ 2x Pizza Margherita - ‚Ç¨24\n‚Ä¢ 1x Coca-Cola - ‚Ç¨3\nüí∞ Total: ‚Ç¨27"

**Client**: "Confirmer"  
**Bot**: "üéâ Commande confirm√©e! Num√©ro: #123\n‚è∞ Temps: 25-30 minutes..."

## üîí S√©curit√©

- Validation des tokens WhatsApp
- Sanitisation des entr√©es utilisateur  
- Rate limiting sur les endpoints
- Logs d√©taill√©s pour monitoring

## üìà Monitoring

- Logs structur√©s avec timestamp
- M√©triques de performance  
- Alertes en cas d'erreur
- Dashboard admin int√©gr√©
"""